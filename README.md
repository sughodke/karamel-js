karamel-js
----------

A JavaScript backend for [KaRaMeL](https://github.com/FStarLang/karamel) — compiles formally verified [Low\*](https://fstarlang.github.io/lowstar/html/) programs to clean, readable ES module JavaScript with zero runtime dependencies.

```
F* (Low*) --> .krml --> KaRaMeL --> JavaScript ES modules
```

## Background

[KaRaMeL](https://github.com/FStarLang/karamel) (K&R meets ML) extracts F\* programs to readable C. It takes Low\*, a subset of F\* that verifies against a low-level memory model (stack, heap, first-order, non-recursive data types), and compiles it through several IR passes:

```
.krml --> Ast --> CStar --> C11 --> .c/.h
```

[CStar](https://github.com/FStarLang/karamel/blob/master/lib/CStar.ml) is KaRaMeL's key intermediate representation — after monomorphization, inlining, struct lowering, and pattern match compilation, it provides a C-like AST that is straightforward to print.

karamel-js adds a direct CStar-to-JavaScript code generator, branching off after CStar and bypassing C11 entirely:

```
.krml --> Ast --> CStar --+--> C11  --> .c/.h    (original KaRaMeL)
                         |
                         +--> CStarToJS --> .js  (karamel-js)
```

## What We Added

### New Files

| File | Purpose |
|---|---|
| [`lib/CStarToJS.ml`](lib/CStarToJS.ml) | CStar to JavaScript pretty-printer (~500 lines). Handles expressions, statements, declarations, operator precedence, typed array selection, and ES module import generation. |
| [`lib/OutputJavaScript.ml`](lib/OutputJavaScript.ml) | File writer. Writes `.js` files to the output directory via PPrint. |

### Modified Files

| File | Change |
|---|---|
| [`lib/Options.ml`](lib/Options.ml) | Added `JS` to the `backend` type and `js ()` helper. |
| [`src/Karamel.ml`](src/Karamel.ml) | Added `-backend js` CLI option and JS pipeline branch. |

### CStar to JavaScript Mapping

| CStar | JavaScript |
|---|---|
| `LowStar.Buffer` (fixed-width integers) | Typed arrays (`Uint32Array`, `Uint8Array`, ...) |
| Struct field access | Object property access |
| Buffer read/write (`buf[i]`) | Array index (`arr[i]`) |
| `BufCreate`, `BufBlit`, `BufFill` | `new TypedArray(n)`, `.set()`, `.fill()` |
| `BufFree` | Skipped (GC handles it) |
| Top-level functions | `export function` |
| Top-level constants | `export let` |
| Cross-module calls | ES module `import { ... } from './Module.js'` |
| Integer casts | Bitwise coercion (`\| 0` for i32, `>>> 0` for u32) |

## Usage

```bash
krml -backend js -tmpdir out/js \
  -skip-compilation -skip-linking \
  -bundle 'FStar.*' -bundle 'LowStar.*' -bundle 'C.*' -bundle 'Prims' \
  out.krml
```

Produces one `.js` ES module per F\* module, with automatic import generation for cross-module references.

## Output Size

Tested with 5 verified CRDT modules (G-Counter, Grow-Only Set, LWW-Register, Two-Phase Set, PN-Counter) — identical verified Low\* source for the first two rows, equivalent Dafny source for the third:

| Approach | Raw | Gzipped | Runtime Deps |
|---|---|---|---|
| **karamel-js** | **3.3 KB** | **893 B** | **none** |
| Dafny `translate js` | 11.3 KB | 1.5 KB | +120 KB (`bignumber.js`) |
| Low\* via Emscripten (WASM) | 21.7 KB | 7.9 KB | loader included |

3.4x smaller than Dafny, 6.5x smaller than WASM — with zero runtime dependencies.

## Example

Given a verified Low\* G-Counter:

```javascript
// Generated by KaRaMeL — F* module: GCounter

export let GCounter_max_nodes = 16;

export function GCounter_get_count(c, node) { return c[node]; }

export function GCounter_increment(c, node) {
  let v = c[node];
  c[node] = v + 1;
}

export function GCounter_merge(dst, src) { GCounter_merge_loop(dst, src, 0); }

function GCounter_merge_loop(dst, src, i) {
  if (i < 16) {
    let d = dst[i];
    let s = src[i];
    let ite = undefined;
    if (d >= s) { ite = d; } else { ite = s; }
    dst[i] = ite;
    GCounter_merge_loop(dst, src, i + 1);
  }
}
```

Callers allocate typed arrays directly:

```javascript
const counter = new Uint32Array(16);
GCounter_increment(counter, 0);
GCounter_increment(counter, 0);
console.log(GCounter_get_count(counter, 0)); // 2
```

## Goals

- Optimized, minimal JS output from formally verified Low\* code
- Zero runtime dependencies — only built-in JS primitives
- ES module output with tree-shaking friendly exports
- Readable output that maps clearly back to the verified source

## Building

KaRaMeL requires OCaml (>= 4.10.0), OPAM, and a recent version of GNU make.

**Regarding GNU make:** On OSX, this may require you to install a recent GNU
make via homebrew, and invoke `gmake` instead of `make`.

**Regarding OCaml:** Install OPAM via your package manager, then:

`$ opam install ppx_deriving_yojson zarith pprint "menhir>=20161115" sedlex process fix "wasm>=2.0.0" visitors ctypes-foreign ctypes uucp`

Next, make sure you have an up-to-date F\*, either as a binary package
or that you have built it by running `make`. The `fstar.exe` executable
should be on your PATH, or you may set the variable `FSTAR_EXE` to its
location.

To build just run `make` from this directory.

**Note:** on OSX, KaRaMeL is happier if you have `greadlink` installed (`brew
install coreutils`).

### Building with Nix

```bash
nix-shell shell.nix --run "dune build"
```

## License

KaRaMeL is released under the [Apache 2.0 license] and MIT license; see `LICENSE-*` for more details.

[Apache 2.0 license]: https://www.apache.org/licenses/LICENSE-2.0
